// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package tests

//go:generate minimock -i authProject/internal/service.UserService -o user_service_mock_test.go -n UserServiceMock -p tests

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// UserServiceMock implements mm_service.UserService
type UserServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGenerateToken          func(username string) (s1 string, err error)
	funcGenerateTokenOrigin    string
	inspectFuncGenerateToken   func(username string)
	afterGenerateTokenCounter  uint64
	beforeGenerateTokenCounter uint64
	GenerateTokenMock          mUserServiceMockGenerateToken

	funcRefreshToken          func(token string) (s1 string, err error)
	funcRefreshTokenOrigin    string
	inspectFuncRefreshToken   func(token string)
	afterRefreshTokenCounter  uint64
	beforeRefreshTokenCounter uint64
	RefreshTokenMock          mUserServiceMockRefreshToken

	funcRegister          func(username string, password string) (err error)
	funcRegisterOrigin    string
	inspectFuncRegister   func(username string, password string)
	afterRegisterCounter  uint64
	beforeRegisterCounter uint64
	RegisterMock          mUserServiceMockRegister

	funcValidateCredentials          func(username string, password string) (b1 bool, err error)
	funcValidateCredentialsOrigin    string
	inspectFuncValidateCredentials   func(username string, password string)
	afterValidateCredentialsCounter  uint64
	beforeValidateCredentialsCounter uint64
	ValidateCredentialsMock          mUserServiceMockValidateCredentials
}

// NewUserServiceMock returns a mock for mm_service.UserService
func NewUserServiceMock(t minimock.Tester) *UserServiceMock {
	m := &UserServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GenerateTokenMock = mUserServiceMockGenerateToken{mock: m}
	m.GenerateTokenMock.callArgs = []*UserServiceMockGenerateTokenParams{}

	m.RefreshTokenMock = mUserServiceMockRefreshToken{mock: m}
	m.RefreshTokenMock.callArgs = []*UserServiceMockRefreshTokenParams{}

	m.RegisterMock = mUserServiceMockRegister{mock: m}
	m.RegisterMock.callArgs = []*UserServiceMockRegisterParams{}

	m.ValidateCredentialsMock = mUserServiceMockValidateCredentials{mock: m}
	m.ValidateCredentialsMock.callArgs = []*UserServiceMockValidateCredentialsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserServiceMockGenerateToken struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockGenerateTokenExpectation
	expectations       []*UserServiceMockGenerateTokenExpectation

	callArgs []*UserServiceMockGenerateTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserServiceMockGenerateTokenExpectation specifies expectation struct of the UserService.GenerateToken
type UserServiceMockGenerateTokenExpectation struct {
	mock               *UserServiceMock
	params             *UserServiceMockGenerateTokenParams
	paramPtrs          *UserServiceMockGenerateTokenParamPtrs
	expectationOrigins UserServiceMockGenerateTokenExpectationOrigins
	results            *UserServiceMockGenerateTokenResults
	returnOrigin       string
	Counter            uint64
}

// UserServiceMockGenerateTokenParams contains parameters of the UserService.GenerateToken
type UserServiceMockGenerateTokenParams struct {
	username string
}

// UserServiceMockGenerateTokenParamPtrs contains pointers to parameters of the UserService.GenerateToken
type UserServiceMockGenerateTokenParamPtrs struct {
	username *string
}

// UserServiceMockGenerateTokenResults contains results of the UserService.GenerateToken
type UserServiceMockGenerateTokenResults struct {
	s1  string
	err error
}

// UserServiceMockGenerateTokenOrigins contains origins of expectations of the UserService.GenerateToken
type UserServiceMockGenerateTokenExpectationOrigins struct {
	origin         string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGenerateToken *mUserServiceMockGenerateToken) Optional() *mUserServiceMockGenerateToken {
	mmGenerateToken.optional = true
	return mmGenerateToken
}

// Expect sets up expected params for UserService.GenerateToken
func (mmGenerateToken *mUserServiceMockGenerateToken) Expect(username string) *mUserServiceMockGenerateToken {
	if mmGenerateToken.mock.funcGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("UserServiceMock.GenerateToken mock is already set by Set")
	}

	if mmGenerateToken.defaultExpectation == nil {
		mmGenerateToken.defaultExpectation = &UserServiceMockGenerateTokenExpectation{}
	}

	if mmGenerateToken.defaultExpectation.paramPtrs != nil {
		mmGenerateToken.mock.t.Fatalf("UserServiceMock.GenerateToken mock is already set by ExpectParams functions")
	}

	mmGenerateToken.defaultExpectation.params = &UserServiceMockGenerateTokenParams{username}
	mmGenerateToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGenerateToken.expectations {
		if minimock.Equal(e.params, mmGenerateToken.defaultExpectation.params) {
			mmGenerateToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGenerateToken.defaultExpectation.params)
		}
	}

	return mmGenerateToken
}

// ExpectUsernameParam1 sets up expected param username for UserService.GenerateToken
func (mmGenerateToken *mUserServiceMockGenerateToken) ExpectUsernameParam1(username string) *mUserServiceMockGenerateToken {
	if mmGenerateToken.mock.funcGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("UserServiceMock.GenerateToken mock is already set by Set")
	}

	if mmGenerateToken.defaultExpectation == nil {
		mmGenerateToken.defaultExpectation = &UserServiceMockGenerateTokenExpectation{}
	}

	if mmGenerateToken.defaultExpectation.params != nil {
		mmGenerateToken.mock.t.Fatalf("UserServiceMock.GenerateToken mock is already set by Expect")
	}

	if mmGenerateToken.defaultExpectation.paramPtrs == nil {
		mmGenerateToken.defaultExpectation.paramPtrs = &UserServiceMockGenerateTokenParamPtrs{}
	}
	mmGenerateToken.defaultExpectation.paramPtrs.username = &username
	mmGenerateToken.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGenerateToken
}

// Inspect accepts an inspector function that has same arguments as the UserService.GenerateToken
func (mmGenerateToken *mUserServiceMockGenerateToken) Inspect(f func(username string)) *mUserServiceMockGenerateToken {
	if mmGenerateToken.mock.inspectFuncGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("Inspect function is already set for UserServiceMock.GenerateToken")
	}

	mmGenerateToken.mock.inspectFuncGenerateToken = f

	return mmGenerateToken
}

// Return sets up results that will be returned by UserService.GenerateToken
func (mmGenerateToken *mUserServiceMockGenerateToken) Return(s1 string, err error) *UserServiceMock {
	if mmGenerateToken.mock.funcGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("UserServiceMock.GenerateToken mock is already set by Set")
	}

	if mmGenerateToken.defaultExpectation == nil {
		mmGenerateToken.defaultExpectation = &UserServiceMockGenerateTokenExpectation{mock: mmGenerateToken.mock}
	}
	mmGenerateToken.defaultExpectation.results = &UserServiceMockGenerateTokenResults{s1, err}
	mmGenerateToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGenerateToken.mock
}

// Set uses given function f to mock the UserService.GenerateToken method
func (mmGenerateToken *mUserServiceMockGenerateToken) Set(f func(username string) (s1 string, err error)) *UserServiceMock {
	if mmGenerateToken.defaultExpectation != nil {
		mmGenerateToken.mock.t.Fatalf("Default expectation is already set for the UserService.GenerateToken method")
	}

	if len(mmGenerateToken.expectations) > 0 {
		mmGenerateToken.mock.t.Fatalf("Some expectations are already set for the UserService.GenerateToken method")
	}

	mmGenerateToken.mock.funcGenerateToken = f
	mmGenerateToken.mock.funcGenerateTokenOrigin = minimock.CallerInfo(1)
	return mmGenerateToken.mock
}

// When sets expectation for the UserService.GenerateToken which will trigger the result defined by the following
// Then helper
func (mmGenerateToken *mUserServiceMockGenerateToken) When(username string) *UserServiceMockGenerateTokenExpectation {
	if mmGenerateToken.mock.funcGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("UserServiceMock.GenerateToken mock is already set by Set")
	}

	expectation := &UserServiceMockGenerateTokenExpectation{
		mock:               mmGenerateToken.mock,
		params:             &UserServiceMockGenerateTokenParams{username},
		expectationOrigins: UserServiceMockGenerateTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGenerateToken.expectations = append(mmGenerateToken.expectations, expectation)
	return expectation
}

// Then sets up UserService.GenerateToken return parameters for the expectation previously defined by the When method
func (e *UserServiceMockGenerateTokenExpectation) Then(s1 string, err error) *UserServiceMock {
	e.results = &UserServiceMockGenerateTokenResults{s1, err}
	return e.mock
}

// Times sets number of times UserService.GenerateToken should be invoked
func (mmGenerateToken *mUserServiceMockGenerateToken) Times(n uint64) *mUserServiceMockGenerateToken {
	if n == 0 {
		mmGenerateToken.mock.t.Fatalf("Times of UserServiceMock.GenerateToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGenerateToken.expectedInvocations, n)
	mmGenerateToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGenerateToken
}

func (mmGenerateToken *mUserServiceMockGenerateToken) invocationsDone() bool {
	if len(mmGenerateToken.expectations) == 0 && mmGenerateToken.defaultExpectation == nil && mmGenerateToken.mock.funcGenerateToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGenerateToken.mock.afterGenerateTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGenerateToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GenerateToken implements mm_service.UserService
func (mmGenerateToken *UserServiceMock) GenerateToken(username string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGenerateToken.beforeGenerateTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGenerateToken.afterGenerateTokenCounter, 1)

	mmGenerateToken.t.Helper()

	if mmGenerateToken.inspectFuncGenerateToken != nil {
		mmGenerateToken.inspectFuncGenerateToken(username)
	}

	mm_params := UserServiceMockGenerateTokenParams{username}

	// Record call args
	mmGenerateToken.GenerateTokenMock.mutex.Lock()
	mmGenerateToken.GenerateTokenMock.callArgs = append(mmGenerateToken.GenerateTokenMock.callArgs, &mm_params)
	mmGenerateToken.GenerateTokenMock.mutex.Unlock()

	for _, e := range mmGenerateToken.GenerateTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGenerateToken.GenerateTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGenerateToken.GenerateTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGenerateToken.GenerateTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGenerateToken.GenerateTokenMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockGenerateTokenParams{username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGenerateToken.t.Errorf("UserServiceMock.GenerateToken got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGenerateToken.GenerateTokenMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGenerateToken.t.Errorf("UserServiceMock.GenerateToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGenerateToken.GenerateTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGenerateToken.GenerateTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGenerateToken.t.Fatal("No results are set for the UserServiceMock.GenerateToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGenerateToken.funcGenerateToken != nil {
		return mmGenerateToken.funcGenerateToken(username)
	}
	mmGenerateToken.t.Fatalf("Unexpected call to UserServiceMock.GenerateToken. %v", username)
	return
}

// GenerateTokenAfterCounter returns a count of finished UserServiceMock.GenerateToken invocations
func (mmGenerateToken *UserServiceMock) GenerateTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateToken.afterGenerateTokenCounter)
}

// GenerateTokenBeforeCounter returns a count of UserServiceMock.GenerateToken invocations
func (mmGenerateToken *UserServiceMock) GenerateTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateToken.beforeGenerateTokenCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.GenerateToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGenerateToken *mUserServiceMockGenerateToken) Calls() []*UserServiceMockGenerateTokenParams {
	mmGenerateToken.mutex.RLock()

	argCopy := make([]*UserServiceMockGenerateTokenParams, len(mmGenerateToken.callArgs))
	copy(argCopy, mmGenerateToken.callArgs)

	mmGenerateToken.mutex.RUnlock()

	return argCopy
}

// MinimockGenerateTokenDone returns true if the count of the GenerateToken invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockGenerateTokenDone() bool {
	if m.GenerateTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GenerateTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GenerateTokenMock.invocationsDone()
}

// MinimockGenerateTokenInspect logs each unmet expectation
func (m *UserServiceMock) MinimockGenerateTokenInspect() {
	for _, e := range m.GenerateTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.GenerateToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGenerateTokenCounter := mm_atomic.LoadUint64(&m.afterGenerateTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateTokenMock.defaultExpectation != nil && afterGenerateTokenCounter < 1 {
		if m.GenerateTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserServiceMock.GenerateToken at\n%s", m.GenerateTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserServiceMock.GenerateToken at\n%s with params: %#v", m.GenerateTokenMock.defaultExpectation.expectationOrigins.origin, *m.GenerateTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateToken != nil && afterGenerateTokenCounter < 1 {
		m.t.Errorf("Expected call to UserServiceMock.GenerateToken at\n%s", m.funcGenerateTokenOrigin)
	}

	if !m.GenerateTokenMock.invocationsDone() && afterGenerateTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.GenerateToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GenerateTokenMock.expectedInvocations), m.GenerateTokenMock.expectedInvocationsOrigin, afterGenerateTokenCounter)
	}
}

type mUserServiceMockRefreshToken struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockRefreshTokenExpectation
	expectations       []*UserServiceMockRefreshTokenExpectation

	callArgs []*UserServiceMockRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserServiceMockRefreshTokenExpectation specifies expectation struct of the UserService.RefreshToken
type UserServiceMockRefreshTokenExpectation struct {
	mock               *UserServiceMock
	params             *UserServiceMockRefreshTokenParams
	paramPtrs          *UserServiceMockRefreshTokenParamPtrs
	expectationOrigins UserServiceMockRefreshTokenExpectationOrigins
	results            *UserServiceMockRefreshTokenResults
	returnOrigin       string
	Counter            uint64
}

// UserServiceMockRefreshTokenParams contains parameters of the UserService.RefreshToken
type UserServiceMockRefreshTokenParams struct {
	token string
}

// UserServiceMockRefreshTokenParamPtrs contains pointers to parameters of the UserService.RefreshToken
type UserServiceMockRefreshTokenParamPtrs struct {
	token *string
}

// UserServiceMockRefreshTokenResults contains results of the UserService.RefreshToken
type UserServiceMockRefreshTokenResults struct {
	s1  string
	err error
}

// UserServiceMockRefreshTokenOrigins contains origins of expectations of the UserService.RefreshToken
type UserServiceMockRefreshTokenExpectationOrigins struct {
	origin      string
	originToken string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRefreshToken *mUserServiceMockRefreshToken) Optional() *mUserServiceMockRefreshToken {
	mmRefreshToken.optional = true
	return mmRefreshToken
}

// Expect sets up expected params for UserService.RefreshToken
func (mmRefreshToken *mUserServiceMockRefreshToken) Expect(token string) *mUserServiceMockRefreshToken {
	if mmRefreshToken.mock.funcRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("UserServiceMock.RefreshToken mock is already set by Set")
	}

	if mmRefreshToken.defaultExpectation == nil {
		mmRefreshToken.defaultExpectation = &UserServiceMockRefreshTokenExpectation{}
	}

	if mmRefreshToken.defaultExpectation.paramPtrs != nil {
		mmRefreshToken.mock.t.Fatalf("UserServiceMock.RefreshToken mock is already set by ExpectParams functions")
	}

	mmRefreshToken.defaultExpectation.params = &UserServiceMockRefreshTokenParams{token}
	mmRefreshToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRefreshToken.expectations {
		if minimock.Equal(e.params, mmRefreshToken.defaultExpectation.params) {
			mmRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRefreshToken.defaultExpectation.params)
		}
	}

	return mmRefreshToken
}

// ExpectTokenParam1 sets up expected param token for UserService.RefreshToken
func (mmRefreshToken *mUserServiceMockRefreshToken) ExpectTokenParam1(token string) *mUserServiceMockRefreshToken {
	if mmRefreshToken.mock.funcRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("UserServiceMock.RefreshToken mock is already set by Set")
	}

	if mmRefreshToken.defaultExpectation == nil {
		mmRefreshToken.defaultExpectation = &UserServiceMockRefreshTokenExpectation{}
	}

	if mmRefreshToken.defaultExpectation.params != nil {
		mmRefreshToken.mock.t.Fatalf("UserServiceMock.RefreshToken mock is already set by Expect")
	}

	if mmRefreshToken.defaultExpectation.paramPtrs == nil {
		mmRefreshToken.defaultExpectation.paramPtrs = &UserServiceMockRefreshTokenParamPtrs{}
	}
	mmRefreshToken.defaultExpectation.paramPtrs.token = &token
	mmRefreshToken.defaultExpectation.expectationOrigins.originToken = minimock.CallerInfo(1)

	return mmRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the UserService.RefreshToken
func (mmRefreshToken *mUserServiceMockRefreshToken) Inspect(f func(token string)) *mUserServiceMockRefreshToken {
	if mmRefreshToken.mock.inspectFuncRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("Inspect function is already set for UserServiceMock.RefreshToken")
	}

	mmRefreshToken.mock.inspectFuncRefreshToken = f

	return mmRefreshToken
}

// Return sets up results that will be returned by UserService.RefreshToken
func (mmRefreshToken *mUserServiceMockRefreshToken) Return(s1 string, err error) *UserServiceMock {
	if mmRefreshToken.mock.funcRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("UserServiceMock.RefreshToken mock is already set by Set")
	}

	if mmRefreshToken.defaultExpectation == nil {
		mmRefreshToken.defaultExpectation = &UserServiceMockRefreshTokenExpectation{mock: mmRefreshToken.mock}
	}
	mmRefreshToken.defaultExpectation.results = &UserServiceMockRefreshTokenResults{s1, err}
	mmRefreshToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRefreshToken.mock
}

// Set uses given function f to mock the UserService.RefreshToken method
func (mmRefreshToken *mUserServiceMockRefreshToken) Set(f func(token string) (s1 string, err error)) *UserServiceMock {
	if mmRefreshToken.defaultExpectation != nil {
		mmRefreshToken.mock.t.Fatalf("Default expectation is already set for the UserService.RefreshToken method")
	}

	if len(mmRefreshToken.expectations) > 0 {
		mmRefreshToken.mock.t.Fatalf("Some expectations are already set for the UserService.RefreshToken method")
	}

	mmRefreshToken.mock.funcRefreshToken = f
	mmRefreshToken.mock.funcRefreshTokenOrigin = minimock.CallerInfo(1)
	return mmRefreshToken.mock
}

// When sets expectation for the UserService.RefreshToken which will trigger the result defined by the following
// Then helper
func (mmRefreshToken *mUserServiceMockRefreshToken) When(token string) *UserServiceMockRefreshTokenExpectation {
	if mmRefreshToken.mock.funcRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("UserServiceMock.RefreshToken mock is already set by Set")
	}

	expectation := &UserServiceMockRefreshTokenExpectation{
		mock:               mmRefreshToken.mock,
		params:             &UserServiceMockRefreshTokenParams{token},
		expectationOrigins: UserServiceMockRefreshTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRefreshToken.expectations = append(mmRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up UserService.RefreshToken return parameters for the expectation previously defined by the When method
func (e *UserServiceMockRefreshTokenExpectation) Then(s1 string, err error) *UserServiceMock {
	e.results = &UserServiceMockRefreshTokenResults{s1, err}
	return e.mock
}

// Times sets number of times UserService.RefreshToken should be invoked
func (mmRefreshToken *mUserServiceMockRefreshToken) Times(n uint64) *mUserServiceMockRefreshToken {
	if n == 0 {
		mmRefreshToken.mock.t.Fatalf("Times of UserServiceMock.RefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRefreshToken.expectedInvocations, n)
	mmRefreshToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRefreshToken
}

func (mmRefreshToken *mUserServiceMockRefreshToken) invocationsDone() bool {
	if len(mmRefreshToken.expectations) == 0 && mmRefreshToken.defaultExpectation == nil && mmRefreshToken.mock.funcRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRefreshToken.mock.afterRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RefreshToken implements mm_service.UserService
func (mmRefreshToken *UserServiceMock) RefreshToken(token string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmRefreshToken.beforeRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmRefreshToken.afterRefreshTokenCounter, 1)

	mmRefreshToken.t.Helper()

	if mmRefreshToken.inspectFuncRefreshToken != nil {
		mmRefreshToken.inspectFuncRefreshToken(token)
	}

	mm_params := UserServiceMockRefreshTokenParams{token}

	// Record call args
	mmRefreshToken.RefreshTokenMock.mutex.Lock()
	mmRefreshToken.RefreshTokenMock.callArgs = append(mmRefreshToken.RefreshTokenMock.callArgs, &mm_params)
	mmRefreshToken.RefreshTokenMock.mutex.Unlock()

	for _, e := range mmRefreshToken.RefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmRefreshToken.RefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRefreshToken.RefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmRefreshToken.RefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmRefreshToken.RefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockRefreshTokenParams{token}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.token != nil && !minimock.Equal(*mm_want_ptrs.token, mm_got.token) {
				mmRefreshToken.t.Errorf("UserServiceMock.RefreshToken got unexpected parameter token, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefreshToken.RefreshTokenMock.defaultExpectation.expectationOrigins.originToken, *mm_want_ptrs.token, mm_got.token, minimock.Diff(*mm_want_ptrs.token, mm_got.token))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRefreshToken.t.Errorf("UserServiceMock.RefreshToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRefreshToken.RefreshTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRefreshToken.RefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmRefreshToken.t.Fatal("No results are set for the UserServiceMock.RefreshToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmRefreshToken.funcRefreshToken != nil {
		return mmRefreshToken.funcRefreshToken(token)
	}
	mmRefreshToken.t.Fatalf("Unexpected call to UserServiceMock.RefreshToken. %v", token)
	return
}

// RefreshTokenAfterCounter returns a count of finished UserServiceMock.RefreshToken invocations
func (mmRefreshToken *UserServiceMock) RefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshToken.afterRefreshTokenCounter)
}

// RefreshTokenBeforeCounter returns a count of UserServiceMock.RefreshToken invocations
func (mmRefreshToken *UserServiceMock) RefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshToken.beforeRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.RefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRefreshToken *mUserServiceMockRefreshToken) Calls() []*UserServiceMockRefreshTokenParams {
	mmRefreshToken.mutex.RLock()

	argCopy := make([]*UserServiceMockRefreshTokenParams, len(mmRefreshToken.callArgs))
	copy(argCopy, mmRefreshToken.callArgs)

	mmRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockRefreshTokenDone returns true if the count of the RefreshToken invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockRefreshTokenDone() bool {
	if m.RefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RefreshTokenMock.invocationsDone()
}

// MinimockRefreshTokenInspect logs each unmet expectation
func (m *UserServiceMock) MinimockRefreshTokenInspect() {
	for _, e := range m.RefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.RefreshToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RefreshTokenMock.defaultExpectation != nil && afterRefreshTokenCounter < 1 {
		if m.RefreshTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserServiceMock.RefreshToken at\n%s", m.RefreshTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserServiceMock.RefreshToken at\n%s with params: %#v", m.RefreshTokenMock.defaultExpectation.expectationOrigins.origin, *m.RefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefreshToken != nil && afterRefreshTokenCounter < 1 {
		m.t.Errorf("Expected call to UserServiceMock.RefreshToken at\n%s", m.funcRefreshTokenOrigin)
	}

	if !m.RefreshTokenMock.invocationsDone() && afterRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.RefreshToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RefreshTokenMock.expectedInvocations), m.RefreshTokenMock.expectedInvocationsOrigin, afterRefreshTokenCounter)
	}
}

type mUserServiceMockRegister struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockRegisterExpectation
	expectations       []*UserServiceMockRegisterExpectation

	callArgs []*UserServiceMockRegisterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserServiceMockRegisterExpectation specifies expectation struct of the UserService.Register
type UserServiceMockRegisterExpectation struct {
	mock               *UserServiceMock
	params             *UserServiceMockRegisterParams
	paramPtrs          *UserServiceMockRegisterParamPtrs
	expectationOrigins UserServiceMockRegisterExpectationOrigins
	results            *UserServiceMockRegisterResults
	returnOrigin       string
	Counter            uint64
}

// UserServiceMockRegisterParams contains parameters of the UserService.Register
type UserServiceMockRegisterParams struct {
	username string
	password string
}

// UserServiceMockRegisterParamPtrs contains pointers to parameters of the UserService.Register
type UserServiceMockRegisterParamPtrs struct {
	username *string
	password *string
}

// UserServiceMockRegisterResults contains results of the UserService.Register
type UserServiceMockRegisterResults struct {
	err error
}

// UserServiceMockRegisterOrigins contains origins of expectations of the UserService.Register
type UserServiceMockRegisterExpectationOrigins struct {
	origin         string
	originUsername string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegister *mUserServiceMockRegister) Optional() *mUserServiceMockRegister {
	mmRegister.optional = true
	return mmRegister
}

// Expect sets up expected params for UserService.Register
func (mmRegister *mUserServiceMockRegister) Expect(username string, password string) *mUserServiceMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UserServiceMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &UserServiceMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.paramPtrs != nil {
		mmRegister.mock.t.Fatalf("UserServiceMock.Register mock is already set by ExpectParams functions")
	}

	mmRegister.defaultExpectation.params = &UserServiceMockRegisterParams{username, password}
	mmRegister.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegister.expectations {
		if minimock.Equal(e.params, mmRegister.defaultExpectation.params) {
			mmRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegister.defaultExpectation.params)
		}
	}

	return mmRegister
}

// ExpectUsernameParam1 sets up expected param username for UserService.Register
func (mmRegister *mUserServiceMockRegister) ExpectUsernameParam1(username string) *mUserServiceMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UserServiceMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &UserServiceMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.params != nil {
		mmRegister.mock.t.Fatalf("UserServiceMock.Register mock is already set by Expect")
	}

	if mmRegister.defaultExpectation.paramPtrs == nil {
		mmRegister.defaultExpectation.paramPtrs = &UserServiceMockRegisterParamPtrs{}
	}
	mmRegister.defaultExpectation.paramPtrs.username = &username
	mmRegister.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmRegister
}

// ExpectPasswordParam2 sets up expected param password for UserService.Register
func (mmRegister *mUserServiceMockRegister) ExpectPasswordParam2(password string) *mUserServiceMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UserServiceMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &UserServiceMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.params != nil {
		mmRegister.mock.t.Fatalf("UserServiceMock.Register mock is already set by Expect")
	}

	if mmRegister.defaultExpectation.paramPtrs == nil {
		mmRegister.defaultExpectation.paramPtrs = &UserServiceMockRegisterParamPtrs{}
	}
	mmRegister.defaultExpectation.paramPtrs.password = &password
	mmRegister.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmRegister
}

// Inspect accepts an inspector function that has same arguments as the UserService.Register
func (mmRegister *mUserServiceMockRegister) Inspect(f func(username string, password string)) *mUserServiceMockRegister {
	if mmRegister.mock.inspectFuncRegister != nil {
		mmRegister.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Register")
	}

	mmRegister.mock.inspectFuncRegister = f

	return mmRegister
}

// Return sets up results that will be returned by UserService.Register
func (mmRegister *mUserServiceMockRegister) Return(err error) *UserServiceMock {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UserServiceMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &UserServiceMockRegisterExpectation{mock: mmRegister.mock}
	}
	mmRegister.defaultExpectation.results = &UserServiceMockRegisterResults{err}
	mmRegister.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegister.mock
}

// Set uses given function f to mock the UserService.Register method
func (mmRegister *mUserServiceMockRegister) Set(f func(username string, password string) (err error)) *UserServiceMock {
	if mmRegister.defaultExpectation != nil {
		mmRegister.mock.t.Fatalf("Default expectation is already set for the UserService.Register method")
	}

	if len(mmRegister.expectations) > 0 {
		mmRegister.mock.t.Fatalf("Some expectations are already set for the UserService.Register method")
	}

	mmRegister.mock.funcRegister = f
	mmRegister.mock.funcRegisterOrigin = minimock.CallerInfo(1)
	return mmRegister.mock
}

// When sets expectation for the UserService.Register which will trigger the result defined by the following
// Then helper
func (mmRegister *mUserServiceMockRegister) When(username string, password string) *UserServiceMockRegisterExpectation {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UserServiceMock.Register mock is already set by Set")
	}

	expectation := &UserServiceMockRegisterExpectation{
		mock:               mmRegister.mock,
		params:             &UserServiceMockRegisterParams{username, password},
		expectationOrigins: UserServiceMockRegisterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegister.expectations = append(mmRegister.expectations, expectation)
	return expectation
}

// Then sets up UserService.Register return parameters for the expectation previously defined by the When method
func (e *UserServiceMockRegisterExpectation) Then(err error) *UserServiceMock {
	e.results = &UserServiceMockRegisterResults{err}
	return e.mock
}

// Times sets number of times UserService.Register should be invoked
func (mmRegister *mUserServiceMockRegister) Times(n uint64) *mUserServiceMockRegister {
	if n == 0 {
		mmRegister.mock.t.Fatalf("Times of UserServiceMock.Register mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegister.expectedInvocations, n)
	mmRegister.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegister
}

func (mmRegister *mUserServiceMockRegister) invocationsDone() bool {
	if len(mmRegister.expectations) == 0 && mmRegister.defaultExpectation == nil && mmRegister.mock.funcRegister == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegister.mock.afterRegisterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegister.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Register implements mm_service.UserService
func (mmRegister *UserServiceMock) Register(username string, password string) (err error) {
	mm_atomic.AddUint64(&mmRegister.beforeRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmRegister.afterRegisterCounter, 1)

	mmRegister.t.Helper()

	if mmRegister.inspectFuncRegister != nil {
		mmRegister.inspectFuncRegister(username, password)
	}

	mm_params := UserServiceMockRegisterParams{username, password}

	// Record call args
	mmRegister.RegisterMock.mutex.Lock()
	mmRegister.RegisterMock.callArgs = append(mmRegister.RegisterMock.callArgs, &mm_params)
	mmRegister.RegisterMock.mutex.Unlock()

	for _, e := range mmRegister.RegisterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRegister.RegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegister.RegisterMock.defaultExpectation.Counter, 1)
		mm_want := mmRegister.RegisterMock.defaultExpectation.params
		mm_want_ptrs := mmRegister.RegisterMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockRegisterParams{username, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmRegister.t.Errorf("UserServiceMock.Register got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegister.RegisterMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmRegister.t.Errorf("UserServiceMock.Register got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegister.RegisterMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegister.t.Errorf("UserServiceMock.Register got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegister.RegisterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegister.RegisterMock.defaultExpectation.results
		if mm_results == nil {
			mmRegister.t.Fatal("No results are set for the UserServiceMock.Register")
		}
		return (*mm_results).err
	}
	if mmRegister.funcRegister != nil {
		return mmRegister.funcRegister(username, password)
	}
	mmRegister.t.Fatalf("Unexpected call to UserServiceMock.Register. %v %v", username, password)
	return
}

// RegisterAfterCounter returns a count of finished UserServiceMock.Register invocations
func (mmRegister *UserServiceMock) RegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.afterRegisterCounter)
}

// RegisterBeforeCounter returns a count of UserServiceMock.Register invocations
func (mmRegister *UserServiceMock) RegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.beforeRegisterCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Register.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegister *mUserServiceMockRegister) Calls() []*UserServiceMockRegisterParams {
	mmRegister.mutex.RLock()

	argCopy := make([]*UserServiceMockRegisterParams, len(mmRegister.callArgs))
	copy(argCopy, mmRegister.callArgs)

	mmRegister.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterDone returns true if the count of the Register invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockRegisterDone() bool {
	if m.RegisterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterMock.invocationsDone()
}

// MinimockRegisterInspect logs each unmet expectation
func (m *UserServiceMock) MinimockRegisterInspect() {
	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Register at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterCounter := mm_atomic.LoadUint64(&m.afterRegisterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMock.defaultExpectation != nil && afterRegisterCounter < 1 {
		if m.RegisterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserServiceMock.Register at\n%s", m.RegisterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Register at\n%s with params: %#v", m.RegisterMock.defaultExpectation.expectationOrigins.origin, *m.RegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegister != nil && afterRegisterCounter < 1 {
		m.t.Errorf("Expected call to UserServiceMock.Register at\n%s", m.funcRegisterOrigin)
	}

	if !m.RegisterMock.invocationsDone() && afterRegisterCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.Register at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterMock.expectedInvocations), m.RegisterMock.expectedInvocationsOrigin, afterRegisterCounter)
	}
}

type mUserServiceMockValidateCredentials struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockValidateCredentialsExpectation
	expectations       []*UserServiceMockValidateCredentialsExpectation

	callArgs []*UserServiceMockValidateCredentialsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserServiceMockValidateCredentialsExpectation specifies expectation struct of the UserService.ValidateCredentials
type UserServiceMockValidateCredentialsExpectation struct {
	mock               *UserServiceMock
	params             *UserServiceMockValidateCredentialsParams
	paramPtrs          *UserServiceMockValidateCredentialsParamPtrs
	expectationOrigins UserServiceMockValidateCredentialsExpectationOrigins
	results            *UserServiceMockValidateCredentialsResults
	returnOrigin       string
	Counter            uint64
}

// UserServiceMockValidateCredentialsParams contains parameters of the UserService.ValidateCredentials
type UserServiceMockValidateCredentialsParams struct {
	username string
	password string
}

// UserServiceMockValidateCredentialsParamPtrs contains pointers to parameters of the UserService.ValidateCredentials
type UserServiceMockValidateCredentialsParamPtrs struct {
	username *string
	password *string
}

// UserServiceMockValidateCredentialsResults contains results of the UserService.ValidateCredentials
type UserServiceMockValidateCredentialsResults struct {
	b1  bool
	err error
}

// UserServiceMockValidateCredentialsOrigins contains origins of expectations of the UserService.ValidateCredentials
type UserServiceMockValidateCredentialsExpectationOrigins struct {
	origin         string
	originUsername string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateCredentials *mUserServiceMockValidateCredentials) Optional() *mUserServiceMockValidateCredentials {
	mmValidateCredentials.optional = true
	return mmValidateCredentials
}

// Expect sets up expected params for UserService.ValidateCredentials
func (mmValidateCredentials *mUserServiceMockValidateCredentials) Expect(username string, password string) *mUserServiceMockValidateCredentials {
	if mmValidateCredentials.mock.funcValidateCredentials != nil {
		mmValidateCredentials.mock.t.Fatalf("UserServiceMock.ValidateCredentials mock is already set by Set")
	}

	if mmValidateCredentials.defaultExpectation == nil {
		mmValidateCredentials.defaultExpectation = &UserServiceMockValidateCredentialsExpectation{}
	}

	if mmValidateCredentials.defaultExpectation.paramPtrs != nil {
		mmValidateCredentials.mock.t.Fatalf("UserServiceMock.ValidateCredentials mock is already set by ExpectParams functions")
	}

	mmValidateCredentials.defaultExpectation.params = &UserServiceMockValidateCredentialsParams{username, password}
	mmValidateCredentials.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmValidateCredentials.expectations {
		if minimock.Equal(e.params, mmValidateCredentials.defaultExpectation.params) {
			mmValidateCredentials.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateCredentials.defaultExpectation.params)
		}
	}

	return mmValidateCredentials
}

// ExpectUsernameParam1 sets up expected param username for UserService.ValidateCredentials
func (mmValidateCredentials *mUserServiceMockValidateCredentials) ExpectUsernameParam1(username string) *mUserServiceMockValidateCredentials {
	if mmValidateCredentials.mock.funcValidateCredentials != nil {
		mmValidateCredentials.mock.t.Fatalf("UserServiceMock.ValidateCredentials mock is already set by Set")
	}

	if mmValidateCredentials.defaultExpectation == nil {
		mmValidateCredentials.defaultExpectation = &UserServiceMockValidateCredentialsExpectation{}
	}

	if mmValidateCredentials.defaultExpectation.params != nil {
		mmValidateCredentials.mock.t.Fatalf("UserServiceMock.ValidateCredentials mock is already set by Expect")
	}

	if mmValidateCredentials.defaultExpectation.paramPtrs == nil {
		mmValidateCredentials.defaultExpectation.paramPtrs = &UserServiceMockValidateCredentialsParamPtrs{}
	}
	mmValidateCredentials.defaultExpectation.paramPtrs.username = &username
	mmValidateCredentials.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmValidateCredentials
}

// ExpectPasswordParam2 sets up expected param password for UserService.ValidateCredentials
func (mmValidateCredentials *mUserServiceMockValidateCredentials) ExpectPasswordParam2(password string) *mUserServiceMockValidateCredentials {
	if mmValidateCredentials.mock.funcValidateCredentials != nil {
		mmValidateCredentials.mock.t.Fatalf("UserServiceMock.ValidateCredentials mock is already set by Set")
	}

	if mmValidateCredentials.defaultExpectation == nil {
		mmValidateCredentials.defaultExpectation = &UserServiceMockValidateCredentialsExpectation{}
	}

	if mmValidateCredentials.defaultExpectation.params != nil {
		mmValidateCredentials.mock.t.Fatalf("UserServiceMock.ValidateCredentials mock is already set by Expect")
	}

	if mmValidateCredentials.defaultExpectation.paramPtrs == nil {
		mmValidateCredentials.defaultExpectation.paramPtrs = &UserServiceMockValidateCredentialsParamPtrs{}
	}
	mmValidateCredentials.defaultExpectation.paramPtrs.password = &password
	mmValidateCredentials.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmValidateCredentials
}

// Inspect accepts an inspector function that has same arguments as the UserService.ValidateCredentials
func (mmValidateCredentials *mUserServiceMockValidateCredentials) Inspect(f func(username string, password string)) *mUserServiceMockValidateCredentials {
	if mmValidateCredentials.mock.inspectFuncValidateCredentials != nil {
		mmValidateCredentials.mock.t.Fatalf("Inspect function is already set for UserServiceMock.ValidateCredentials")
	}

	mmValidateCredentials.mock.inspectFuncValidateCredentials = f

	return mmValidateCredentials
}

// Return sets up results that will be returned by UserService.ValidateCredentials
func (mmValidateCredentials *mUserServiceMockValidateCredentials) Return(b1 bool, err error) *UserServiceMock {
	if mmValidateCredentials.mock.funcValidateCredentials != nil {
		mmValidateCredentials.mock.t.Fatalf("UserServiceMock.ValidateCredentials mock is already set by Set")
	}

	if mmValidateCredentials.defaultExpectation == nil {
		mmValidateCredentials.defaultExpectation = &UserServiceMockValidateCredentialsExpectation{mock: mmValidateCredentials.mock}
	}
	mmValidateCredentials.defaultExpectation.results = &UserServiceMockValidateCredentialsResults{b1, err}
	mmValidateCredentials.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmValidateCredentials.mock
}

// Set uses given function f to mock the UserService.ValidateCredentials method
func (mmValidateCredentials *mUserServiceMockValidateCredentials) Set(f func(username string, password string) (b1 bool, err error)) *UserServiceMock {
	if mmValidateCredentials.defaultExpectation != nil {
		mmValidateCredentials.mock.t.Fatalf("Default expectation is already set for the UserService.ValidateCredentials method")
	}

	if len(mmValidateCredentials.expectations) > 0 {
		mmValidateCredentials.mock.t.Fatalf("Some expectations are already set for the UserService.ValidateCredentials method")
	}

	mmValidateCredentials.mock.funcValidateCredentials = f
	mmValidateCredentials.mock.funcValidateCredentialsOrigin = minimock.CallerInfo(1)
	return mmValidateCredentials.mock
}

// When sets expectation for the UserService.ValidateCredentials which will trigger the result defined by the following
// Then helper
func (mmValidateCredentials *mUserServiceMockValidateCredentials) When(username string, password string) *UserServiceMockValidateCredentialsExpectation {
	if mmValidateCredentials.mock.funcValidateCredentials != nil {
		mmValidateCredentials.mock.t.Fatalf("UserServiceMock.ValidateCredentials mock is already set by Set")
	}

	expectation := &UserServiceMockValidateCredentialsExpectation{
		mock:               mmValidateCredentials.mock,
		params:             &UserServiceMockValidateCredentialsParams{username, password},
		expectationOrigins: UserServiceMockValidateCredentialsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmValidateCredentials.expectations = append(mmValidateCredentials.expectations, expectation)
	return expectation
}

// Then sets up UserService.ValidateCredentials return parameters for the expectation previously defined by the When method
func (e *UserServiceMockValidateCredentialsExpectation) Then(b1 bool, err error) *UserServiceMock {
	e.results = &UserServiceMockValidateCredentialsResults{b1, err}
	return e.mock
}

// Times sets number of times UserService.ValidateCredentials should be invoked
func (mmValidateCredentials *mUserServiceMockValidateCredentials) Times(n uint64) *mUserServiceMockValidateCredentials {
	if n == 0 {
		mmValidateCredentials.mock.t.Fatalf("Times of UserServiceMock.ValidateCredentials mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateCredentials.expectedInvocations, n)
	mmValidateCredentials.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmValidateCredentials
}

func (mmValidateCredentials *mUserServiceMockValidateCredentials) invocationsDone() bool {
	if len(mmValidateCredentials.expectations) == 0 && mmValidateCredentials.defaultExpectation == nil && mmValidateCredentials.mock.funcValidateCredentials == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateCredentials.mock.afterValidateCredentialsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateCredentials.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateCredentials implements mm_service.UserService
func (mmValidateCredentials *UserServiceMock) ValidateCredentials(username string, password string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmValidateCredentials.beforeValidateCredentialsCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateCredentials.afterValidateCredentialsCounter, 1)

	mmValidateCredentials.t.Helper()

	if mmValidateCredentials.inspectFuncValidateCredentials != nil {
		mmValidateCredentials.inspectFuncValidateCredentials(username, password)
	}

	mm_params := UserServiceMockValidateCredentialsParams{username, password}

	// Record call args
	mmValidateCredentials.ValidateCredentialsMock.mutex.Lock()
	mmValidateCredentials.ValidateCredentialsMock.callArgs = append(mmValidateCredentials.ValidateCredentialsMock.callArgs, &mm_params)
	mmValidateCredentials.ValidateCredentialsMock.mutex.Unlock()

	for _, e := range mmValidateCredentials.ValidateCredentialsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmValidateCredentials.ValidateCredentialsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateCredentials.ValidateCredentialsMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateCredentials.ValidateCredentialsMock.defaultExpectation.params
		mm_want_ptrs := mmValidateCredentials.ValidateCredentialsMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockValidateCredentialsParams{username, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmValidateCredentials.t.Errorf("UserServiceMock.ValidateCredentials got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateCredentials.ValidateCredentialsMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmValidateCredentials.t.Errorf("UserServiceMock.ValidateCredentials got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateCredentials.ValidateCredentialsMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateCredentials.t.Errorf("UserServiceMock.ValidateCredentials got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmValidateCredentials.ValidateCredentialsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateCredentials.ValidateCredentialsMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateCredentials.t.Fatal("No results are set for the UserServiceMock.ValidateCredentials")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmValidateCredentials.funcValidateCredentials != nil {
		return mmValidateCredentials.funcValidateCredentials(username, password)
	}
	mmValidateCredentials.t.Fatalf("Unexpected call to UserServiceMock.ValidateCredentials. %v %v", username, password)
	return
}

// ValidateCredentialsAfterCounter returns a count of finished UserServiceMock.ValidateCredentials invocations
func (mmValidateCredentials *UserServiceMock) ValidateCredentialsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateCredentials.afterValidateCredentialsCounter)
}

// ValidateCredentialsBeforeCounter returns a count of UserServiceMock.ValidateCredentials invocations
func (mmValidateCredentials *UserServiceMock) ValidateCredentialsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateCredentials.beforeValidateCredentialsCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.ValidateCredentials.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateCredentials *mUserServiceMockValidateCredentials) Calls() []*UserServiceMockValidateCredentialsParams {
	mmValidateCredentials.mutex.RLock()

	argCopy := make([]*UserServiceMockValidateCredentialsParams, len(mmValidateCredentials.callArgs))
	copy(argCopy, mmValidateCredentials.callArgs)

	mmValidateCredentials.mutex.RUnlock()

	return argCopy
}

// MinimockValidateCredentialsDone returns true if the count of the ValidateCredentials invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockValidateCredentialsDone() bool {
	if m.ValidateCredentialsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateCredentialsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateCredentialsMock.invocationsDone()
}

// MinimockValidateCredentialsInspect logs each unmet expectation
func (m *UserServiceMock) MinimockValidateCredentialsInspect() {
	for _, e := range m.ValidateCredentialsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.ValidateCredentials at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterValidateCredentialsCounter := mm_atomic.LoadUint64(&m.afterValidateCredentialsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateCredentialsMock.defaultExpectation != nil && afterValidateCredentialsCounter < 1 {
		if m.ValidateCredentialsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserServiceMock.ValidateCredentials at\n%s", m.ValidateCredentialsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserServiceMock.ValidateCredentials at\n%s with params: %#v", m.ValidateCredentialsMock.defaultExpectation.expectationOrigins.origin, *m.ValidateCredentialsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateCredentials != nil && afterValidateCredentialsCounter < 1 {
		m.t.Errorf("Expected call to UserServiceMock.ValidateCredentials at\n%s", m.funcValidateCredentialsOrigin)
	}

	if !m.ValidateCredentialsMock.invocationsDone() && afterValidateCredentialsCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.ValidateCredentials at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateCredentialsMock.expectedInvocations), m.ValidateCredentialsMock.expectedInvocationsOrigin, afterValidateCredentialsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGenerateTokenInspect()

			m.MinimockRefreshTokenInspect()

			m.MinimockRegisterInspect()

			m.MinimockValidateCredentialsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGenerateTokenDone() &&
		m.MinimockRefreshTokenDone() &&
		m.MinimockRegisterDone() &&
		m.MinimockValidateCredentialsDone()
}
